//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.24.0
// 	protoc        v3.15.6
// source: ratis-grpc.proto

package ratis

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

var File_ratis_grpc_proto protoreflect.FileDescriptor

var file_ratis_grpc_proto_rawDesc = []byte{
	0x0a, 0x10, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2d, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x12, 0x0a, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x1a, 0x0a,
	0x72, 0x61, 0x66, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x32, 0xb9, 0x02, 0x0a, 0x19, 0x52,
	0x61, 0x66, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
	0x6c, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x64, 0x0a, 0x10, 0x73, 0x65, 0x74, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x2e, 0x72,
	0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x53, 0x65, 0x74, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73,
	0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x61, 0x66, 0x74, 0x43, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x00, 0x12, 0x59,
	0x0a, 0x07, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x65, 0x64, 0x12, 0x24, 0x2e, 0x72, 0x61, 0x74, 0x69,
	0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x61, 0x66, 0x74, 0x43, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
	0x22, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52,
	0x61, 0x66, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0x00, 0x28, 0x01, 0x30, 0x01, 0x12, 0x5b, 0x0a, 0x09, 0x75, 0x6e, 0x6f,
	0x72, 0x64, 0x65, 0x72, 0x65, 0x64, 0x12, 0x24, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x61, 0x66, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x2e, 0x72,
	0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x61, 0x66, 0x74,
	0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x22, 0x00, 0x28, 0x01, 0x30, 0x01, 0x32, 0xca, 0x02, 0x0a, 0x19, 0x52, 0x61, 0x66, 0x74, 0x53,
	0x65, 0x72, 0x76, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x53, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x12, 0x5b, 0x0a, 0x0b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x56,
	0x6f, 0x74, 0x65, 0x12, 0x25, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x56, 0x6f, 0x74, 0x65, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x23, 0x2e, 0x72, 0x61, 0x74,
	0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x56, 0x6f, 0x74, 0x65, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22,
	0x00, 0x12, 0x65, 0x0a, 0x0d, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x45, 0x6e, 0x74, 0x72, 0x69,
	0x65, 0x73, 0x12, 0x27, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x41, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x25, 0x2e, 0x72, 0x61,
	0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x70, 0x70, 0x65, 0x6e,
	0x64, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0x00, 0x28, 0x01, 0x30, 0x01, 0x12, 0x69, 0x0a, 0x0f, 0x69, 0x6e, 0x73, 0x74,
	0x61, 0x6c, 0x6c, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x29, 0x2e, 0x72, 0x61,
	0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61,
	0x6c, 0x6c, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x53, 0x6e, 0x61,
	0x70, 0x73, 0x68, 0x6f, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22,
	0x00, 0x28, 0x01, 0x32, 0xa8, 0x02, 0x0a, 0x14, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x62, 0x0a, 0x0f,
	0x67, 0x72, 0x6f, 0x75, 0x70, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12,
	0x29, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x47,
	0x72, 0x6f, 0x75, 0x70, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x2e, 0x72, 0x61, 0x74,
	0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x61, 0x66, 0x74, 0x43, 0x6c,
	0x69, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x00,
	0x12, 0x55, 0x0a, 0x09, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x23, 0x2e,
	0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x47, 0x72, 0x6f,
	0x75, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x1a, 0x21, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x00, 0x12, 0x55, 0x0a, 0x09, 0x67, 0x72, 0x6f, 0x75, 0x70,
	0x49, 0x6e, 0x66, 0x6f, 0x12, 0x23, 0x2e, 0x72, 0x61, 0x74, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x21, 0x2e, 0x72, 0x61, 0x74, 0x69,
	0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x00, 0x42, 0x58,
	0x0a, 0x1b, 0x6f, 0x72, 0x67, 0x2e, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65, 0x2e, 0x72, 0x61, 0x74,
	0x69, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x42, 0x0a, 0x47,
	0x72, 0x70, 0x63, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x5a, 0x2a, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61, 0x70, 0x61, 0x63, 0x68, 0x65, 0x2f, 0x6f, 0x7a, 0x6f,
	0x6e, 0x65, 0x2d, 0x67, 0x6f, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
	0x72, 0x61, 0x74, 0x69, 0x73, 0xa0, 0x01, 0x01, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var file_ratis_grpc_proto_goTypes = []interface{}{
	(*SetConfigurationRequestProto)(nil), // 0: ratis.common.SetConfigurationRequestProto
	(*RaftClientRequestProto)(nil),       // 1: ratis.common.RaftClientRequestProto
	(*RequestVoteRequestProto)(nil),      // 2: ratis.common.RequestVoteRequestProto
	(*AppendEntriesRequestProto)(nil),    // 3: ratis.common.AppendEntriesRequestProto
	(*InstallSnapshotRequestProto)(nil),  // 4: ratis.common.InstallSnapshotRequestProto
	(*GroupManagementRequestProto)(nil),  // 5: ratis.common.GroupManagementRequestProto
	(*GroupListRequestProto)(nil),        // 6: ratis.common.GroupListRequestProto
	(*GroupInfoRequestProto)(nil),        // 7: ratis.common.GroupInfoRequestProto
	(*RaftClientReplyProto)(nil),         // 8: ratis.common.RaftClientReplyProto
	(*RequestVoteReplyProto)(nil),        // 9: ratis.common.RequestVoteReplyProto
	(*AppendEntriesReplyProto)(nil),      // 10: ratis.common.AppendEntriesReplyProto
	(*InstallSnapshotReplyProto)(nil),    // 11: ratis.common.InstallSnapshotReplyProto
	(*GroupListReplyProto)(nil),          // 12: ratis.common.GroupListReplyProto
	(*GroupInfoReplyProto)(nil),          // 13: ratis.common.GroupInfoReplyProto
}
var file_ratis_grpc_proto_depIdxs = []int32{
	0,  // 0: ratis.grpc.RaftClientProtocolService.setConfiguration:input_type -> ratis.common.SetConfigurationRequestProto
	1,  // 1: ratis.grpc.RaftClientProtocolService.ordered:input_type -> ratis.common.RaftClientRequestProto
	1,  // 2: ratis.grpc.RaftClientProtocolService.unordered:input_type -> ratis.common.RaftClientRequestProto
	2,  // 3: ratis.grpc.RaftServerProtocolService.requestVote:input_type -> ratis.common.RequestVoteRequestProto
	3,  // 4: ratis.grpc.RaftServerProtocolService.appendEntries:input_type -> ratis.common.AppendEntriesRequestProto
	4,  // 5: ratis.grpc.RaftServerProtocolService.installSnapshot:input_type -> ratis.common.InstallSnapshotRequestProto
	5,  // 6: ratis.grpc.AdminProtocolService.groupManagement:input_type -> ratis.common.GroupManagementRequestProto
	6,  // 7: ratis.grpc.AdminProtocolService.groupList:input_type -> ratis.common.GroupListRequestProto
	7,  // 8: ratis.grpc.AdminProtocolService.groupInfo:input_type -> ratis.common.GroupInfoRequestProto
	8,  // 9: ratis.grpc.RaftClientProtocolService.setConfiguration:output_type -> ratis.common.RaftClientReplyProto
	8,  // 10: ratis.grpc.RaftClientProtocolService.ordered:output_type -> ratis.common.RaftClientReplyProto
	8,  // 11: ratis.grpc.RaftClientProtocolService.unordered:output_type -> ratis.common.RaftClientReplyProto
	9,  // 12: ratis.grpc.RaftServerProtocolService.requestVote:output_type -> ratis.common.RequestVoteReplyProto
	10, // 13: ratis.grpc.RaftServerProtocolService.appendEntries:output_type -> ratis.common.AppendEntriesReplyProto
	11, // 14: ratis.grpc.RaftServerProtocolService.installSnapshot:output_type -> ratis.common.InstallSnapshotReplyProto
	8,  // 15: ratis.grpc.AdminProtocolService.groupManagement:output_type -> ratis.common.RaftClientReplyProto
	12, // 16: ratis.grpc.AdminProtocolService.groupList:output_type -> ratis.common.GroupListReplyProto
	13, // 17: ratis.grpc.AdminProtocolService.groupInfo:output_type -> ratis.common.GroupInfoReplyProto
	9,  // [9:18] is the sub-list for method output_type
	0,  // [0:9] is the sub-list for method input_type
	0,  // [0:0] is the sub-list for extension type_name
	0,  // [0:0] is the sub-list for extension extendee
	0,  // [0:0] is the sub-list for field type_name
}

func init() { file_ratis_grpc_proto_init() }
func file_ratis_grpc_proto_init() {
	if File_ratis_grpc_proto != nil {
		return
	}
	file_raft_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_ratis_grpc_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   0,
			NumExtensions: 0,
			NumServices:   3,
		},
		GoTypes:           file_ratis_grpc_proto_goTypes,
		DependencyIndexes: file_ratis_grpc_proto_depIdxs,
	}.Build()
	File_ratis_grpc_proto = out.File
	file_ratis_grpc_proto_rawDesc = nil
	file_ratis_grpc_proto_goTypes = nil
	file_ratis_grpc_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// RaftClientProtocolServiceClient is the client API for RaftClientProtocolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftClientProtocolServiceClient interface {
	// A client-to-server RPC to set new raft configuration
	SetConfiguration(ctx context.Context, in *SetConfigurationRequestProto, opts ...grpc.CallOption) (*RaftClientReplyProto, error)
	// A client-to-server stream RPC to ordered async requests
	Ordered(ctx context.Context, opts ...grpc.CallOption) (RaftClientProtocolService_OrderedClient, error)
	// A client-to-server stream RPC for unordered async requests
	Unordered(ctx context.Context, opts ...grpc.CallOption) (RaftClientProtocolService_UnorderedClient, error)
}

type raftClientProtocolServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRaftClientProtocolServiceClient(cc grpc.ClientConnInterface) RaftClientProtocolServiceClient {
	return &raftClientProtocolServiceClient{cc}
}

func (c *raftClientProtocolServiceClient) SetConfiguration(ctx context.Context, in *SetConfigurationRequestProto, opts ...grpc.CallOption) (*RaftClientReplyProto, error) {
	out := new(RaftClientReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.RaftClientProtocolService/setConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClientProtocolServiceClient) Ordered(ctx context.Context, opts ...grpc.CallOption) (RaftClientProtocolService_OrderedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftClientProtocolService_serviceDesc.Streams[0], "/ratis.grpc.RaftClientProtocolService/ordered", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftClientProtocolServiceOrderedClient{stream}
	return x, nil
}

type RaftClientProtocolService_OrderedClient interface {
	Send(*RaftClientRequestProto) error
	Recv() (*RaftClientReplyProto, error)
	grpc.ClientStream
}

type raftClientProtocolServiceOrderedClient struct {
	grpc.ClientStream
}

func (x *raftClientProtocolServiceOrderedClient) Send(m *RaftClientRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftClientProtocolServiceOrderedClient) Recv() (*RaftClientReplyProto, error) {
	m := new(RaftClientReplyProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClientProtocolServiceClient) Unordered(ctx context.Context, opts ...grpc.CallOption) (RaftClientProtocolService_UnorderedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftClientProtocolService_serviceDesc.Streams[1], "/ratis.grpc.RaftClientProtocolService/unordered", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftClientProtocolServiceUnorderedClient{stream}
	return x, nil
}

type RaftClientProtocolService_UnorderedClient interface {
	Send(*RaftClientRequestProto) error
	Recv() (*RaftClientReplyProto, error)
	grpc.ClientStream
}

type raftClientProtocolServiceUnorderedClient struct {
	grpc.ClientStream
}

func (x *raftClientProtocolServiceUnorderedClient) Send(m *RaftClientRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftClientProtocolServiceUnorderedClient) Recv() (*RaftClientReplyProto, error) {
	m := new(RaftClientReplyProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RaftClientProtocolServiceServer is the server API for RaftClientProtocolService service.
type RaftClientProtocolServiceServer interface {
	// A client-to-server RPC to set new raft configuration
	SetConfiguration(context.Context, *SetConfigurationRequestProto) (*RaftClientReplyProto, error)
	// A client-to-server stream RPC to ordered async requests
	Ordered(RaftClientProtocolService_OrderedServer) error
	// A client-to-server stream RPC for unordered async requests
	Unordered(RaftClientProtocolService_UnorderedServer) error
}

// UnimplementedRaftClientProtocolServiceServer can be embedded to have forward compatible implementations.
type UnimplementedRaftClientProtocolServiceServer struct {
}

func (*UnimplementedRaftClientProtocolServiceServer) SetConfiguration(context.Context, *SetConfigurationRequestProto) (*RaftClientReplyProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConfiguration not implemented")
}
func (*UnimplementedRaftClientProtocolServiceServer) Ordered(RaftClientProtocolService_OrderedServer) error {
	return status.Errorf(codes.Unimplemented, "method Ordered not implemented")
}
func (*UnimplementedRaftClientProtocolServiceServer) Unordered(RaftClientProtocolService_UnorderedServer) error {
	return status.Errorf(codes.Unimplemented, "method Unordered not implemented")
}

func RegisterRaftClientProtocolServiceServer(s *grpc.Server, srv RaftClientProtocolServiceServer) {
	s.RegisterService(&_RaftClientProtocolService_serviceDesc, srv)
}

func _RaftClientProtocolService_SetConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConfigurationRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftClientProtocolServiceServer).SetConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.RaftClientProtocolService/SetConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftClientProtocolServiceServer).SetConfiguration(ctx, req.(*SetConfigurationRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftClientProtocolService_Ordered_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftClientProtocolServiceServer).Ordered(&raftClientProtocolServiceOrderedServer{stream})
}

type RaftClientProtocolService_OrderedServer interface {
	Send(*RaftClientReplyProto) error
	Recv() (*RaftClientRequestProto, error)
	grpc.ServerStream
}

type raftClientProtocolServiceOrderedServer struct {
	grpc.ServerStream
}

func (x *raftClientProtocolServiceOrderedServer) Send(m *RaftClientReplyProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftClientProtocolServiceOrderedServer) Recv() (*RaftClientRequestProto, error) {
	m := new(RaftClientRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RaftClientProtocolService_Unordered_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftClientProtocolServiceServer).Unordered(&raftClientProtocolServiceUnorderedServer{stream})
}

type RaftClientProtocolService_UnorderedServer interface {
	Send(*RaftClientReplyProto) error
	Recv() (*RaftClientRequestProto, error)
	grpc.ServerStream
}

type raftClientProtocolServiceUnorderedServer struct {
	grpc.ServerStream
}

func (x *raftClientProtocolServiceUnorderedServer) Send(m *RaftClientReplyProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftClientProtocolServiceUnorderedServer) Recv() (*RaftClientRequestProto, error) {
	m := new(RaftClientRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftClientProtocolService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ratis.grpc.RaftClientProtocolService",
	HandlerType: (*RaftClientProtocolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "setConfiguration",
			Handler:    _RaftClientProtocolService_SetConfiguration_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ordered",
			Handler:       _RaftClientProtocolService_Ordered_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "unordered",
			Handler:       _RaftClientProtocolService_Unordered_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "ratis-grpc.proto",
}

// RaftServerProtocolServiceClient is the client API for RaftServerProtocolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftServerProtocolServiceClient interface {
	RequestVote(ctx context.Context, in *RequestVoteRequestProto, opts ...grpc.CallOption) (*RequestVoteReplyProto, error)
	AppendEntries(ctx context.Context, opts ...grpc.CallOption) (RaftServerProtocolService_AppendEntriesClient, error)
	InstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (RaftServerProtocolService_InstallSnapshotClient, error)
}

type raftServerProtocolServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRaftServerProtocolServiceClient(cc grpc.ClientConnInterface) RaftServerProtocolServiceClient {
	return &raftServerProtocolServiceClient{cc}
}

func (c *raftServerProtocolServiceClient) RequestVote(ctx context.Context, in *RequestVoteRequestProto, opts ...grpc.CallOption) (*RequestVoteReplyProto, error) {
	out := new(RequestVoteReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.RaftServerProtocolService/requestVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServerProtocolServiceClient) AppendEntries(ctx context.Context, opts ...grpc.CallOption) (RaftServerProtocolService_AppendEntriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftServerProtocolService_serviceDesc.Streams[0], "/ratis.grpc.RaftServerProtocolService/appendEntries", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftServerProtocolServiceAppendEntriesClient{stream}
	return x, nil
}

type RaftServerProtocolService_AppendEntriesClient interface {
	Send(*AppendEntriesRequestProto) error
	Recv() (*AppendEntriesReplyProto, error)
	grpc.ClientStream
}

type raftServerProtocolServiceAppendEntriesClient struct {
	grpc.ClientStream
}

func (x *raftServerProtocolServiceAppendEntriesClient) Send(m *AppendEntriesRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftServerProtocolServiceAppendEntriesClient) Recv() (*AppendEntriesReplyProto, error) {
	m := new(AppendEntriesReplyProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftServerProtocolServiceClient) InstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (RaftServerProtocolService_InstallSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftServerProtocolService_serviceDesc.Streams[1], "/ratis.grpc.RaftServerProtocolService/installSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftServerProtocolServiceInstallSnapshotClient{stream}
	return x, nil
}

type RaftServerProtocolService_InstallSnapshotClient interface {
	Send(*InstallSnapshotRequestProto) error
	CloseAndRecv() (*InstallSnapshotReplyProto, error)
	grpc.ClientStream
}

type raftServerProtocolServiceInstallSnapshotClient struct {
	grpc.ClientStream
}

func (x *raftServerProtocolServiceInstallSnapshotClient) Send(m *InstallSnapshotRequestProto) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftServerProtocolServiceInstallSnapshotClient) CloseAndRecv() (*InstallSnapshotReplyProto, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(InstallSnapshotReplyProto)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RaftServerProtocolServiceServer is the server API for RaftServerProtocolService service.
type RaftServerProtocolServiceServer interface {
	RequestVote(context.Context, *RequestVoteRequestProto) (*RequestVoteReplyProto, error)
	AppendEntries(RaftServerProtocolService_AppendEntriesServer) error
	InstallSnapshot(RaftServerProtocolService_InstallSnapshotServer) error
}

// UnimplementedRaftServerProtocolServiceServer can be embedded to have forward compatible implementations.
type UnimplementedRaftServerProtocolServiceServer struct {
}

func (*UnimplementedRaftServerProtocolServiceServer) RequestVote(context.Context, *RequestVoteRequestProto) (*RequestVoteReplyProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestVote not implemented")
}
func (*UnimplementedRaftServerProtocolServiceServer) AppendEntries(RaftServerProtocolService_AppendEntriesServer) error {
	return status.Errorf(codes.Unimplemented, "method AppendEntries not implemented")
}
func (*UnimplementedRaftServerProtocolServiceServer) InstallSnapshot(RaftServerProtocolService_InstallSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method InstallSnapshot not implemented")
}

func RegisterRaftServerProtocolServiceServer(s *grpc.Server, srv RaftServerProtocolServiceServer) {
	s.RegisterService(&_RaftServerProtocolService_serviceDesc, srv)
}

func _RaftServerProtocolService_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServerProtocolServiceServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.RaftServerProtocolService/RequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServerProtocolServiceServer).RequestVote(ctx, req.(*RequestVoteRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftServerProtocolService_AppendEntries_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServerProtocolServiceServer).AppendEntries(&raftServerProtocolServiceAppendEntriesServer{stream})
}

type RaftServerProtocolService_AppendEntriesServer interface {
	Send(*AppendEntriesReplyProto) error
	Recv() (*AppendEntriesRequestProto, error)
	grpc.ServerStream
}

type raftServerProtocolServiceAppendEntriesServer struct {
	grpc.ServerStream
}

func (x *raftServerProtocolServiceAppendEntriesServer) Send(m *AppendEntriesReplyProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftServerProtocolServiceAppendEntriesServer) Recv() (*AppendEntriesRequestProto, error) {
	m := new(AppendEntriesRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RaftServerProtocolService_InstallSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServerProtocolServiceServer).InstallSnapshot(&raftServerProtocolServiceInstallSnapshotServer{stream})
}

type RaftServerProtocolService_InstallSnapshotServer interface {
	SendAndClose(*InstallSnapshotReplyProto) error
	Recv() (*InstallSnapshotRequestProto, error)
	grpc.ServerStream
}

type raftServerProtocolServiceInstallSnapshotServer struct {
	grpc.ServerStream
}

func (x *raftServerProtocolServiceInstallSnapshotServer) SendAndClose(m *InstallSnapshotReplyProto) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftServerProtocolServiceInstallSnapshotServer) Recv() (*InstallSnapshotRequestProto, error) {
	m := new(InstallSnapshotRequestProto)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftServerProtocolService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ratis.grpc.RaftServerProtocolService",
	HandlerType: (*RaftServerProtocolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "requestVote",
			Handler:    _RaftServerProtocolService_RequestVote_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "appendEntries",
			Handler:       _RaftServerProtocolService_AppendEntries_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "installSnapshot",
			Handler:       _RaftServerProtocolService_InstallSnapshot_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "ratis-grpc.proto",
}

// AdminProtocolServiceClient is the client API for AdminProtocolService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdminProtocolServiceClient interface {
	// A client-to-server RPC to add a new group
	GroupManagement(ctx context.Context, in *GroupManagementRequestProto, opts ...grpc.CallOption) (*RaftClientReplyProto, error)
	GroupList(ctx context.Context, in *GroupListRequestProto, opts ...grpc.CallOption) (*GroupListReplyProto, error)
	GroupInfo(ctx context.Context, in *GroupInfoRequestProto, opts ...grpc.CallOption) (*GroupInfoReplyProto, error)
}

type adminProtocolServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminProtocolServiceClient(cc grpc.ClientConnInterface) AdminProtocolServiceClient {
	return &adminProtocolServiceClient{cc}
}

func (c *adminProtocolServiceClient) GroupManagement(ctx context.Context, in *GroupManagementRequestProto, opts ...grpc.CallOption) (*RaftClientReplyProto, error) {
	out := new(RaftClientReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.AdminProtocolService/groupManagement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminProtocolServiceClient) GroupList(ctx context.Context, in *GroupListRequestProto, opts ...grpc.CallOption) (*GroupListReplyProto, error) {
	out := new(GroupListReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.AdminProtocolService/groupList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminProtocolServiceClient) GroupInfo(ctx context.Context, in *GroupInfoRequestProto, opts ...grpc.CallOption) (*GroupInfoReplyProto, error) {
	out := new(GroupInfoReplyProto)
	err := c.cc.Invoke(ctx, "/ratis.grpc.AdminProtocolService/groupInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminProtocolServiceServer is the server API for AdminProtocolService service.
type AdminProtocolServiceServer interface {
	// A client-to-server RPC to add a new group
	GroupManagement(context.Context, *GroupManagementRequestProto) (*RaftClientReplyProto, error)
	GroupList(context.Context, *GroupListRequestProto) (*GroupListReplyProto, error)
	GroupInfo(context.Context, *GroupInfoRequestProto) (*GroupInfoReplyProto, error)
}

// UnimplementedAdminProtocolServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAdminProtocolServiceServer struct {
}

func (*UnimplementedAdminProtocolServiceServer) GroupManagement(context.Context, *GroupManagementRequestProto) (*RaftClientReplyProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupManagement not implemented")
}
func (*UnimplementedAdminProtocolServiceServer) GroupList(context.Context, *GroupListRequestProto) (*GroupListReplyProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupList not implemented")
}
func (*UnimplementedAdminProtocolServiceServer) GroupInfo(context.Context, *GroupInfoRequestProto) (*GroupInfoReplyProto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupInfo not implemented")
}

func RegisterAdminProtocolServiceServer(s *grpc.Server, srv AdminProtocolServiceServer) {
	s.RegisterService(&_AdminProtocolService_serviceDesc, srv)
}

func _AdminProtocolService_GroupManagement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupManagementRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminProtocolServiceServer).GroupManagement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.AdminProtocolService/GroupManagement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminProtocolServiceServer).GroupManagement(ctx, req.(*GroupManagementRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminProtocolService_GroupList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupListRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminProtocolServiceServer).GroupList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.AdminProtocolService/GroupList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminProtocolServiceServer).GroupList(ctx, req.(*GroupListRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminProtocolService_GroupInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupInfoRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminProtocolServiceServer).GroupInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ratis.grpc.AdminProtocolService/GroupInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminProtocolServiceServer).GroupInfo(ctx, req.(*GroupInfoRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

var _AdminProtocolService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ratis.grpc.AdminProtocolService",
	HandlerType: (*AdminProtocolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "groupManagement",
			Handler:    _AdminProtocolService_GroupManagement_Handler,
		},
		{
			MethodName: "groupList",
			Handler:    _AdminProtocolService_GroupList_Handler,
		},
		{
			MethodName: "groupInfo",
			Handler:    _AdminProtocolService_GroupInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ratis-grpc.proto",
}
